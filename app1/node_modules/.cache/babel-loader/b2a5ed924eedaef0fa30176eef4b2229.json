{"ast":null,"code":"import { normalize_columns_array } from './normalize_columns_array.js';\nimport { init_state } from './init_state.js';\nimport { normalize_options } from './normalize_options.js';\nimport { CsvError } from './CsvError.js';\n\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\n\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function () {\n  let original_options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const {\n        quote\n      } = this.options;\n      const {\n        quoting,\n        needMoreDataSize,\n        recordDelimiterMaxLength\n      } = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength, // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? quote.length + recordDelimiterMaxLength : 0);\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line\n      } = this.options;\n      let {\n        comment,\n        escape,\n        quote,\n        record_delimiter\n      } = this.options;\n      const {\n        bomSkipped,\n        previousBuf,\n        rawBuffer,\n        escapeIsQuote\n      } = this.state;\n      let buf;\n\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      } // Handle UTF BOM\n\n\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength); // Renormalize original options with the new encoding\n\n              this.options = normalize_options({ ...this.original_options,\n                encoding: encoding\n              }); // Options will re-evaluate the Buffer with the new encoding\n\n              ({\n                comment,\n                escape,\n                quote\n              } = this.options);\n              break;\n            }\n          }\n\n          this.state.bomSkipped = true;\n        }\n      }\n\n      const bufLen = buf.length;\n      let pos;\n\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n\n        const chr = buf[pos];\n\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        } // Previous char was a valid escape char\n        // treat the current char as a regular char\n\n\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          } // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n\n\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);\n\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length); // Escape a quote\n              // Treat next char as a regular character\n\n              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                pos += escape.length - 1;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));\n\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found inside a field at line ${this.info.lines}`], this.options, this.__infoField(), {\n                    field: this.state.field\n                  }));\n\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n              if (skipCommentLine) {\n                this.info.comment_lines++; // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n\n                  this.__resetField();\n\n                  this.__resetRecord();\n\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } // Skip if line is empty and skip_empty_lines activated\n\n\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n\n                this.info.bytes = this.state.bufBytesStart + pos;\n\n                const errField = this.__onField();\n\n                if (errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n\n                const errRecord = this.__onRecord(push);\n\n                if (errRecord !== undefined) return errRecord;\n\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n\n            if (this.state.commenting) {\n              continue;\n            }\n\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n\n              const errField = this.__onField();\n\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            return this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));\n          }\n        }\n\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos); // rtrim in non quoting is handle in __onField\n\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n\n          continue;\n        }\n      }\n\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));\n\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n\n            const errField = this.__onField();\n\n            if (errField !== undefined) return errField;\n\n            const errRecord = this.__onRecord(push);\n\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values\n      } = this.options;\n      const {\n        enabled,\n        record\n      } = this.state;\n\n      if (enabled === false) {\n        return this.__resetRecord();\n      } // Convert the first line into column names\n\n\n      const recordLength = record.length;\n\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n\n          return;\n        }\n\n        return this.__firstLineToColumns(record);\n      }\n\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err = columns === false ? new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        }) : new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', ['Invalid Record Length:', `columns length is ${columns.length},`, // rename columns\n        `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        });\n\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n          this.state.error = err; // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n\n          if (finalErr) return finalErr;\n        }\n      }\n\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n\n        return;\n      }\n\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n\n        this.state.recordHasError = false;\n        return;\n      }\n\n      this.info.records++;\n\n      if (from === 1 || this.info.records >= from) {\n        const {\n          objname\n        } = this.options; // With columns, records are object\n\n        if (columns !== false) {\n          const obj = {}; // Transform record array to an object\n\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue; // Turn duplicate columns into an array\n\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          } // Without objname (default)\n\n\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n\n            const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord], push);\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? obj : [obj[objname], obj], push);\n\n            if (err) {\n              return err;\n            }\n          } // Without columns, records are array\n\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n\n            const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord], push);\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? record : [record[objname], record], push);\n\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const {\n        firstLineToHeaders\n      } = this.state;\n\n      try {\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {\n            headers: headers\n          }));\n        }\n\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n\n        this.__resetRecord();\n\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const {\n        cast,\n        encoding,\n        rtrim,\n        max_record_size\n      } = this.options;\n      const {\n        enabled,\n        wasQuoting\n      } = this.state; // Short circuit for the from_line options\n\n      if (enabled === false) {\n        return this.__resetField();\n      }\n\n      let field = this.state.field.toString(encoding);\n\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n\n        if (err !== undefined) return err;\n        field = f;\n      }\n\n      this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const {\n        on_record\n      } = this.options;\n\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const {\n        columns,\n        relax_column_count\n      } = this.options;\n      const isColumns = Array.isArray(columns); // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const {\n          timchars\n        } = this.state;\n\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return timchar.length;\n        }\n\n        return 0;\n      };\n\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const {\n        delimiter,\n        ignore_last_delimiters\n      } = this.options;\n\n      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n        return 0;\n      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n        return 0;\n      }\n\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return del.length;\n        }\n      }\n\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const {\n        record_delimiter\n      } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n\n        if (rd[0] !== chr) {\n          continue;\n        }\n\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n\n        return rd.length;\n      }\n\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const {\n        escape\n      } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const {\n        quote\n      } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const {\n        encoding\n      } = this.options;\n      const chr = buf[pos];\n\n      if (chr === cr) {\n        if (buf[pos + 1] === nl) {\n          this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding));\n          this.state.recordDelimiterMaxLength = 2;\n          return 2;\n        } else {\n          this.options.record_delimiter.push(Buffer.from('\\r', encoding));\n          this.state.recordDelimiterMaxLength = 1;\n          return 1;\n        }\n      } else if (chr === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\n', encoding));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n\n      return 0;\n    },\n    __error: function (msg) {\n      const {\n        encoding,\n        raw,\n        skip_records_with_error\n      } = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        } // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n\n\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return { ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function () {\n      const {\n        columns,\n        raw,\n        encoding\n      } = this.options;\n      return { ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function () {\n      const {\n        columns\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      return { ...this.__infoRecord(),\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        quoting: this.state.wasQuoting\n      };\n    }\n  };\n};\n\nexport { transform, CsvError };","map":{"version":3,"names":["normalize_columns_array","init_state","normalize_options","CsvError","isRecordEmpty","record","every","field","toString","trim","cr","nl","boms","Buffer","from","transform","original_options","info","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","options","state","__needMoreData","i","bufLen","end","quote","quoting","needMoreDataSize","recordDelimiterMaxLength","numOfCharLeft","requiredLength","Math","max","length","parse","nextBuf","push","close","bom","from_line","ltrim","max_record_size","raw","relax_quotes","rtrim","skip_empty_lines","to","to_line","comment","escape","record_delimiter","bomSkipped","previousBuf","rawBuffer","escapeIsQuote","buf","undefined","concat","encoding","compare","bomLength","bufBytesStart","slice","pos","wasRowDelimiter","stop","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","escaping","__isEscape","__isQuote","commenting","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","wasQuoting","err","__error","String","fromCharCode","__infoField","prepend","recordDelimiterLength","skipCommentLine","enabled","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","record_length","lappend","rappend","columns","group_columns_by_name","relax_column_count","relax_column_count_less","relax_column_count_more","skip_records_with_empty_values","recordLength","__firstLineToColumns","expectedRecordLength","error","finalErr","recordHasError","objname","obj","l","disabled","name","Array","isArray","extRecord","Object","assign","__infoRecord","__push","firstLineToHeaders","headers","call","JSON","stringify","normalizedHeaders","reset","cast","trimRight","f","__cast","on_record","isColumns","castField","__isFloat","parseFloat","cast_date","isTrim","timchars","loop1","timchar","j","value","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","delimiter","ignore_last_delimiters","del","rd","rdLength","msg","skip_records_with_error","Error","on_skip","__infoDataSet","header","index","column"],"sources":["/Users/milanravenell/Documents/digital_dash/app/digital-dash-app/node_modules/csv-parse/lib/api/index.js"],"sourcesContent":["\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        recordDelimiterMaxLength,\n        // Skip if the remaining buffer can be record delimiter following the closing quote\n        // 1 is for quote.length\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found inside a field at line ${this.info.lines}`,\n                    ], this.options, this.__infoField(), {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const {encoding} = this.options;\n      const chr = buf[pos];\n      if(chr === cr){\n        if(buf[pos+1] === nl){\n          this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding));\n          this.state.recordDelimiterMaxLength = 2;\n          return 2;\n        }else{\n          this.options.record_delimiter.push(Buffer.from('\\r', encoding));\n          this.state.recordDelimiterMaxLength = 1;\n          return 1;\n        }\n      }else if(chr === nl){\n        this.options.record_delimiter.push(Buffer.from('\\n', encoding));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}